# フレーム分離処理レポート

本レポートでは、`frame_separation.cpp` に実装された漫画ページからコマ（パネル）を抽出する処理フローを詳細に解説する。C++実装で利用している各関数・画像処理の役割を整理し、その後に提示する Python 実装と対応づけられるように構成する。

## 全体概要

処理は以下の 6 段階で構成される。

1. **入力準備と前処理** – 画像の色空間変換や平滑化。
2. **吹き出し領域の除去** – パネル検出を妨げる吹き出しを塗りつぶす。
3. **パネル候補領域の抽出** – 二値化・エッジ検出・ハフ変換による線抽出。
4. **論理積とバウンディングボックス補完** – 直線情報と二値画像を組み合わせ、矩形候補を補完。
5. **パネル境界の決定** – 輪郭近似から矩形パネルを確定させ、角の座標を整形。
6. **パネル切り出し** – アルファマスク付きでパネル画像を切り出し保存。

以下、それぞれのステップを詳述する。

## 1. 入力準備と前処理

- 入力は `cv::Mat src_page`（グレースケールまたは BGR）。
- グレースケールでなければ `cv::cvtColor` で変換。
- BGR 表示用に `color_page` を生成。
- `cv::GaussianBlur`（カーネル 3×3）で平滑化し、ノイズの影響を抑える。

## 2. 吹き出し領域の除去

吹き出しはパネル境界を遮るため、以下の手順で塗りつぶす。

1. **閾値処理**: しきい値 230 の二値化で吹き出し候補を抽出。
2. **モルフォロジー**: `erode → dilate` を 1 回ずつ適用し輪郭を整える。
3. **輪郭抽出**: `cv::findContours` で吹き出し候補の輪郭を検出。
4. **条件判定**: 面積が画像面積の 0.8%〜3%、かつ円形度 `en > 0.4` のものを吹き出しと判断。
5. **塗りつぶし**: `cv::drawContours` で該当輪郭をゼロ塗りし、吹き出し内部を背景化。

これにより吹き出しが黒く塗りつぶされ、以降のパネル抽出が阻害されにくくなる。

## 3. パネル候補領域の抽出

1. **しきい値処理（逆二値）**: 210 の閾値で反転二値化し、パネル内の黒線を白に。
2. **Cannyエッジ検出**: しきい値 (120, 130)、カーネルサイズ 3 でエッジを抽出。
3. **ハフ変換**: 2 種類の角度分解能 (1°、0.5°) で直線を検出。互いに補完する目的。
4. **直線描画**: 検出した直線を空画像に描画し、線情報をビットマップ化。
5. **論理積**: 直線画像と 3-1 の二値画像の AND を取り、直線が存在する白領域のみ残す。

## 4. 論理積とバウンディングボックス補完

- AND 画像から `cv::findContours` で輪郭抽出。
- 各輪郭の外接矩形を描画し、`inverse_bin_img` とビット演算して矩形候補を補完。
- 得られた画像から再度 `findContours` を実行、パネル候補矩形を取得。
- 面積がページ全体の 4.8% 未満の領域はノイズとして除外。

## 5. パネル境界の決定

1. **線形近似**: `approxPolyDP` で輪郭を近似し、角点候補を抽出。
2. **外接矩形**: `cv::boundingRect` でパネルの矩形領域を取得し、端から ±6px を補正。
3. **角点確定**: バウンディングボックス角とページ角距離、輪郭点との距離から最適な 4 点を選ぶ。
4. **端揃え**: 6px 以内なら画像端にスナップさせ、直線的な枠を強調。

## 6. パネル切り出し

- 入力画像を RGBA 化。
- パネルの外側画素のアルファ値を 0 にし、透明背景のパネル画像を生成。
- パネル矩形で切り抜き、ベクタに格納（C++ 実装では `panel_images` に `cv::Mat` を追加）。

## 主要な補助関数

- `extractSpeechBalloon`: 吹き出し輪郭の検出と塗りつぶし。
- `findFrameExistenceArea`: ヒストグラムから左右のページ端を推定し、ページ角を初期化。
- `drawHoughLines` / `drawHoughLines2`: ハフ変換の結果を画像化。
- `createAndImgWithBoundingBox`: 論理積を用いて欠損矩形を補完。
- `judgeAreaOfBoundingBox`: パネル候補として十分な面積か判定。
- `judgeBoundingBoxOverlap`: 矩形の包含・重複を除外。
- `definePanelCorners`, `align2edge`: パネル角の確定と端寄せ。
- `createAlphaImage`: パネル外領域のアルファ値を 0（透明）に変更。

## 実装上の注意点

- 閾値や面積の割合など多くのマジックナンバーが経験的に設定されている。
- ハフ変換で二度直線検出を行うことで、粗い角度分解能と細かい角度分解能を補完。
- アルファマスクを用いることで、パネルの形状（矩形以外の凹凸）が保持される。

## Python 実装との対応

本レポートに対応する Python 実装 (`frame_separation.py`) では、OpenCV (`cv2`) を用いて上記フローを再現している。クラス／関数構成は C++ 実装を踏襲しつつ、Python 以下の要素を追加・変更した。

- クラス `FrameDetector` が主要ロジックを実装。
- ユーティリティ関数として `PanelQuad`, `Line` クラスを Pythonic に再構成。
- 入力画像のバッチ処理や結果保存を CLI から行えるよう `main` 関数を付与。

Python 版の詳細および使用方法についてはリポジトリ内の該当スクリプト末尾に記載している。

## Python 実装の利用方法

1. 依存パッケージをインストールする::

	pip install opencv-python numpy

2. 単一画像でテストする::

	python frame_separation.py --input path/to/page.png --output outputs/

3. ディレクトリ内の複数画像を処理する場合::

	python frame_separation.py --input path/to/pages_dir --output outputs/

生成されるパネル画像は RGBA 形式 (`_panel_01.png` など) で、背景部分はアルファチャンネルが 0 (透明) に設定される。入力画像に応じてパラメータを調整したい場合は、`FrameDetector` クラス内の定数 (閾値、面積比など) を変更する。
